;;;; SPDX-FileCopyrightText: Atlas Engineer LLC
;;;; SPDX-License-Identifier: BSD-3-Clause

(in-package :nkeymaps/tests)

(prove:plan nil)

(defun empty-keymap (&rest parents)
  (apply #'nkeymaps:make-keymap "anonymous" parents))

(prove:subtest "Make key"
  (let* ((key (nkeymaps:make-key :code 38 :value "a" :modifiers '("C")))
         (mod (first (fset:convert 'list (nkeymaps:key-modifiers key)))))
    (prove:is (nkeymaps:key-code key)
              38)
    (prove:is (nkeymaps:key-value key)
              "a")
    (prove:is mod "C" :test #'nkeymaps:modifier=)
    (prove:is mod "control" :test #'nkeymaps:modifier=)
    (prove:is mod nkeymaps:+control+ :test #'nkeymaps:modifier=)
    (prove:isnt mod "" :test #'nkeymaps:modifier=)
    (prove:isnt mod "M" :test #'nkeymaps:modifier=)
    (prove:isnt mod "meta" :test #'nkeymaps:modifier=)))

(prove:subtest "Make bad key"
  (prove:is-error (nkeymaps:make-key :value "a" :status :dummy)
                  'type-error)
  (prove:is-error (nkeymaps:make-key :value "a" :modifiers '("Z"))
                  'nkeymaps:bad-modifier)
  (prove:is-error (nkeymaps:make-key :status :pressed)
                  'nkeymaps:make-key-required-arg))

(prove:subtest "Make same key"
  (prove:is (nkeymaps:make-key :value "a" :modifiers '("C" "M"))
            (nkeymaps:make-key :value "a" :modifiers '("M" "C"))
            :test #'nkeymaps:key=)
  (prove:is (nkeymaps:make-key :value "a" :modifiers '("C"))
            (nkeymaps:make-key :value "a" :modifiers '("control"))
            :test #'nkeymaps:key=))

(prove:subtest "Make key with duplicate modifiers (trigger warning)"
  (prove:is (nkeymaps:make-key :value "a" :modifiers '("C" "control"))
            (nkeymaps:make-key :value "a" :modifiers '("C"))
            :test #'nkeymaps:key=))

(prove:subtest "Make different key"
  (prove:isnt (nkeymaps:make-key :value "a")
              (nkeymaps:make-key :value "A")
              :test #'nkeymaps:key=))

(prove:subtest "Keyspec->key"
  (prove:is (nkeymaps::keyspec->key "a")
            (nkeymaps:make-key :value "a")
            :test #'nkeymaps:key=)
  (prove:is (nkeymaps::keyspec->key "C-a")
            (nkeymaps:make-key :value "a" :modifiers '("C"))
            :test #'nkeymaps:key=)
  (prove:is (nkeymaps::keyspec->key "C-M-a")
            (nkeymaps:make-key :value "a" :modifiers '("C" "M"))
            :test #'nkeymaps:key=)
  (prove:is (nkeymaps::keyspec->key "C--")
            (nkeymaps:make-key :value "-" :modifiers '("C"))
            :test #'nkeymaps:key=)
  (prove:is (nkeymaps::keyspec->key "C-M--")
            (nkeymaps:make-key :value "-" :modifiers '("C" "M"))
            :test #'nkeymaps:key=)
  (prove:is (nkeymaps::keyspec->key "C-#")
            (nkeymaps:make-key :value "#" :modifiers '("C"))
            :test #'nkeymaps:key=)
  (prove:is (nkeymaps::keyspec->key "#")
            (nkeymaps:make-key :value "#")
            :test #'nkeymaps:key=)
  (prove:is (nkeymaps::keyspec->key "-")
            (nkeymaps:make-key :value "-")
            :test #'nkeymaps:key=)
  (prove:is (nkeymaps::keyspec->key "C-#10")
            (nkeymaps:make-key :code 10 :modifiers '("C"))
            :test #'nkeymaps:key=)
  (prove:is-error (nkeymaps::keyspec->key "")
                  'nkeymaps:empty-keyspec)
  (prove:is-error (nkeymaps::keyspec->key "C-")
                  'nkeymaps:empty-value)
  (prove:is-error (nkeymaps::keyspec->key "C---")
                  'nkeymaps:empty-modifiers))

(defun binding= (keys1 keys2)
  (not (position nil (mapcar #'nkeymaps:key= keys1 keys2))))

(prove:subtest "Keyspecs->keys"
  (prove:is (nkeymaps::keyspecs->keys "C-x C-f")
            (list (nkeymaps:make-key :value "x" :modifiers '("C"))
                  (nkeymaps:make-key :value "f" :modifiers '("C")))
            :test #'binding=)
  (prove:is (nkeymaps::keyspecs->keys "  C-x   C-f  ")
            (list (nkeymaps:make-key :value "x" :modifiers '("C"))
                  (nkeymaps:make-key :value "f" :modifiers '("C")))
            :test #'binding=))

(prove:subtest "define-key & lookup-key"
  (let ((keymap (empty-keymap)))
    (nkeymaps:define-key keymap "C-x" 'foo)
    (prove:is (nkeymaps:lookup-key "C-x" keymap)
              'foo)
    (nkeymaps:define-key keymap "C-x" 'foo2)
    (prove:is (nkeymaps:lookup-key "C-x" keymap)
              'foo2)
    (nkeymaps:define-key keymap "C-c C-f" 'bar)
    (prove:is (nkeymaps:lookup-key "C-c C-f" keymap)
              'bar)
    (nkeymaps:define-key keymap "C-c C-h" 'bar2)
    (prove:is (nkeymaps:lookup-key "C-c C-h" keymap)
              'bar2)))

(prove:subtest "define-key type error"
  (let ((keymap (empty-keymap)))
    (setf (nkeymaps:bound-type keymap) '(or nkeymaps::keymap function))
    (prove:is (nkeymaps:define-key keymap "C-x" #'format)
              keymap)
    (prove:is-error (nkeymaps:define-key keymap "C-c" 'append)
                    'type-error)))

(prove:subtest "define-key & multiple bindings"
  (let ((keymap (empty-keymap)))
    (nkeymaps:define-key keymap
      "C-x" 'foo
      "C-c" 'bar)
    (prove:is (nkeymaps:lookup-key "C-x" keymap)
              'foo)
    (prove:is (nkeymaps:lookup-key "C-c" keymap)
              'bar)))

(prove:subtest "define-key & lookup-key with parents"
  (let* ((parent1 (empty-keymap))
         (parent2 (empty-keymap))
         (keymap (empty-keymap parent1 parent2)))
    (nkeymaps:define-key parent1 "x" 'parent1-x)
    (nkeymaps:define-key parent1 "a" 'parent1-a)
    (nkeymaps:define-key parent2 "x" 'parent2-x)
    (nkeymaps:define-key parent2 "b" 'parent2-b)
    (prove:is (nkeymaps:lookup-key "x" keymap)
              'parent1-x)
    (prove:is (nkeymaps:lookup-key "a" keymap)
              'parent1-a)
    (prove:is (nkeymaps:lookup-key "b" keymap)
              'parent2-b)))

(prove:subtest "define-key & lookup-key with prefix keymap"
  (let ((keymap (empty-keymap))
        (prefix (empty-keymap)))
    (nkeymaps:define-key keymap "C-c" prefix)
    (nkeymaps:define-key prefix "x" 'prefix-sym)
    (prove:is (nkeymaps:lookup-key "C-c x" keymap)
              'prefix-sym)))

(prove:subtest "define-key & lookup-key with cycle"
  (let ((keymap (empty-keymap))
        (parent1 (empty-keymap))
        (parent2 (empty-keymap)))
    (push parent1 (nkeymaps:parents keymap))
    (push parent2 (nkeymaps:parents parent1))
    (push keymap (nkeymaps:parents parent2))
    (prove:is (nkeymaps:lookup-key "x" keymap)
              nil)))

(prove:subtest "Translator"
  (let ((keymap (empty-keymap)))
    (nkeymaps:define-key keymap "A b" 'foo)
    (prove:is (nkeymaps:lookup-key "shift-a shift-B" keymap)
              'foo)
    (nkeymaps:define-key keymap "c" 'bar)
    (prove:is (nkeymaps:lookup-key "shift-c" keymap)
              'bar)
    (nkeymaps:define-key keymap "C-x c" 'baz)
    (prove:is (nkeymaps:lookup-key "C-x C-c" keymap)
              'baz)
    (nkeymaps:define-key keymap "C-c F" 'qux)
    (prove:is (nkeymaps:lookup-key "C-shift-c C-shift-F" keymap)
              'qux)
    (nkeymaps:define-key keymap "1" 'quux)
    (prove:is (nkeymaps:lookup-key "shift-1" keymap)
              'quux)
    (nkeymaps:define-key keymap "return" 'ret)
    (prove:is (nkeymaps:lookup-key "shift-return" keymap)
              'ret)))

(prove:subtest "Translator: Ensure other keymaps have priority over translations"
  (let ((keymap (empty-keymap))
        (keymap2 (empty-keymap)))
    (nkeymaps:define-key keymap "g g" 'prefix-g)
    (nkeymaps:define-key keymap2 "G" 'up-g)
    (prove:is (nkeymaps:lookup-key "s-G" (list keymap keymap2))
              'up-g)))

(prove:subtest "keys->keyspecs"
  (prove:is (nkeymaps:keys->keyspecs (list (nkeymaps:make-key :code 10 :value "a")))
            "#10")
  (prove:is (nkeymaps:keys->keyspecs (list (nkeymaps:make-key :value "a")
                                          (nkeymaps:make-key :value "b")))
            "a b")
  (prove:is (nkeymaps:keys->keyspecs (list (nkeymaps:make-key :value "a" :modifiers '("C"))))
            "C-a")
  (prove:is (nkeymaps:keys->keyspecs (list (nkeymaps:make-key :value "a" :modifiers '("C" "M"))))
            "C-M-a")
  (prove:is (nkeymaps:keys->keyspecs (list (nkeymaps:make-key :value "a" :modifiers '("M" "C"))))
            "C-M-a")
  (prove:is (nkeymaps:keys->keyspecs (list (nkeymaps:make-key :value "a" :modifiers '("C" "M"))
                                          (nkeymaps:make-key :value "x" :modifiers '("super" "hyper"))))
            "C-M-a H-S-x")
  (let ((nkeymaps:*print-shortcut* nil))
    (prove:is (nkeymaps:keys->keyspecs (list (nkeymaps:make-key :value "a" :modifiers '("C"))))
              "control-a")))

(prove:subtest "keymap->map"
  (let ((keymap (empty-keymap))
        (keymap2 (empty-keymap)))
    (nkeymaps:define-key keymap "a" 'foo-a)
    (nkeymaps:define-key keymap "b" 'foo-b)
    (nkeymaps:define-key keymap "k" keymap2)
    (nkeymaps:define-key keymap2 "a" 'bar-a)
    (nkeymaps:define-key keymap2 "c" 'bar-c)
    (prove:is (fset:convert 'fset:map (nkeymaps:keymap->map keymap))
              (fset:map ("a" 'foo-a)
                        ("b" 'foo-b)
                        ("k a" 'bar-a)
                        ("k c" 'bar-c))
              :test #'fset:equal?)
    (prove:is (fset:convert 'fset:map (nkeymaps:keymap->map keymap keymap2))
              (fset:map ("a" 'foo-a)
                        ("b" 'foo-b)
                        ("c" 'bar-c)
                        ("k a" 'bar-a)
                        ("k c" 'bar-c))
              :test #'fset:equal?)
    (prove:is (fset:convert 'fset:map (nkeymaps:keymap->map keymap2 keymap))
              (fset:map ("a" 'bar-a)
                        ("b" 'foo-b)
                        ("c" 'bar-c)
                        ("k a" 'bar-a)
                        ("k c" 'bar-c))
              :test #'fset:equal?)))

(prove:subtest "keymap->map with cycles" ; TODO: Can we check warnings?
  (let ((keymap (empty-keymap))
        (keymap2 (empty-keymap)))
    (nkeymaps:define-key keymap "k" keymap2)
    (nkeymaps:define-key keymap2 "a" keymap)
    (prove:is (fset:convert 'fset:map (nkeymaps:keymap->map keymap))
              (fset:empty-map)
              :test #'fset:equal?))
  (let ((keymap (empty-keymap))
        (keymap2 (empty-keymap))
        (keymap3 (empty-keymap)))
    (nkeymaps:define-key keymap "k" keymap2)
    (nkeymaps:define-key keymap2 "a" keymap3)
    (nkeymaps:define-key keymap3 "b" keymap)
    (prove:is (fset:convert 'fset:map (nkeymaps:keymap->map keymap))
              (fset:empty-map)
              :test #'fset:equal?)))

(prove:subtest "keymap-with-parents->map"
  (let* ((grand-parent (empty-keymap))
         (parent1 (empty-keymap))
         (parent2 (empty-keymap grand-parent))
         (keymap (empty-keymap parent1 parent2)))
    (nkeymaps:define-key keymap "a" 'foo-a)
    (nkeymaps:define-key parent1 "b" 'bar-b)
    (nkeymaps:define-key parent2 "c" 'qux-c)
    (nkeymaps:define-key grand-parent "d" 'quux-d)
    (prove:is (fset:convert 'fset:map (nkeymaps:keymap-with-parents->map keymap))
              (fset:map ("a" 'foo-a)
                        ("b" 'bar-b)
                        ("c" 'qux-c)
                        ("d" 'quux-d))
              :test #'fset:equal?)
    (nkeymaps:define-key parent2 "d" 'qux-d)
    (prove:is (fset:convert 'fset:map (nkeymaps:keymap-with-parents->map keymap))
              (fset:map ("a" 'foo-a)
                        ("b" 'bar-b)
                        ("c" 'qux-c)
                        ("d" 'qux-d))
              :test #'fset:equal?)
    (nkeymaps:define-key parent1 "c" 'bar-c)
    (prove:is (fset:convert 'fset:map (nkeymaps:keymap-with-parents->map keymap))
              (fset:map ("a" 'foo-a)
                        ("b" 'bar-b)
                        ("c" 'bar-c)
                        ("d" 'qux-d))
              :test #'fset:equal?)
    (nkeymaps:define-key parent1 "b" 'foo-b)
    (prove:is (fset:convert 'fset:map (nkeymaps:keymap-with-parents->map keymap))
              (fset:map ("a" 'foo-a)
                        ("b" 'foo-b)
                        ("c" 'bar-c)
                        ("d" 'qux-d))
              :test #'fset:equal?)))

(prove:subtest "keymap-with-parents->map with cycles" ; TODO: Can we check warnings?
  (let ((keymap1 (empty-keymap))
        (keymap2 (empty-keymap)))
    (push keymap1 (nkeymaps:parents keymap2))
    (push keymap2 (nkeymaps:parents keymap1))
    (prove:is (fset:convert 'fset:map (nkeymaps:keymap-with-parents->map keymap1))
              (fset:empty-map)
              :test #'fset:equal?))
  (let ((keymap1 (empty-keymap))
        (keymap2 (empty-keymap))
        (keymap3 (empty-keymap)))
    (push keymap1 (nkeymaps:parents keymap2))
    (push keymap2 (nkeymaps:parents keymap3))
    (push keymap3 (nkeymaps:parents keymap1))
    (prove:is (fset:convert 'fset:map (nkeymaps:keymap-with-parents->map keymap1))
              (fset:empty-map)
              :test #'fset:equal?)))

(prove:subtest "compose-keymaps"
  (let* ((parent1 (empty-keymap))
         (keymap1 (nkeymaps:make-keymap "1" parent1))
         (parent2 (empty-keymap))
         (keymap2 (nkeymaps:make-keymap "2" parent2))
         (keymap3 (empty-keymap)))
    (nkeymaps:define-key keymap1 "a" 'foo-a)
    (nkeymaps:define-key keymap1 "b" 'foo-b)
    (nkeymaps:define-key keymap2 "b" 'bar-b)
    (nkeymaps:define-key keymap2 "c" 'bar-c)
    (nkeymaps:define-key keymap3 "c" 'qux-c)
    (nkeymaps:define-key keymap3 "d" 'qux-d)
    (let ((composition (nkeymaps:compose keymap1 keymap2 keymap3)))
      (prove:is (nkeymaps:name composition)
                "1+2+anonymous")
      (prove:is (fset:convert 'fset:map (nkeymaps:keymap->map composition))
                (fset:map
                 ("a" 'foo-a)
                 ("b" 'foo-b)
                 ("c" 'bar-c)
                 ("d" 'qux-d))
                :test #'fset:equal?)
      (prove:is (nkeymaps:parents composition)
                (list parent1 parent2)))))

(prove:subtest "compose: Altering source does not impact composition"
  (let* ((keymap1 (nkeymaps:make-keymap "1"))
         (keymap2 nil))
    (nkeymaps:define-key keymap1 "a" 'foo-a)
    (setf keymap2 (nkeymaps:compose keymap1))
    (nkeymaps:define-key keymap1 "a" 'foo-a-alt)
    (nkeymaps:define-key keymap1 "b" 'new-foo)
    (prove:is (fset:convert 'fset:map (nkeymaps:keymap->map keymap2))
              (fset:map
               ("a" 'foo-a))
              :test #'fset:equal?)))

(prove:subtest "binding-keys"
  (let* ((keymap1 (empty-keymap))
         (keymap2 (empty-keymap))
         (keymap3 (empty-keymap keymap1)))
    (nkeymaps:define-key keymap1 "a" 'foo-a)
    (nkeymaps:define-key keymap1 "b" 'foo-b)
    (nkeymaps:define-key keymap1 "C-c a" 'foo-a)

    (prove:is (multiple-value-list (nkeymaps:binding-keys 'foo-a keymap1))
              `(("C-c a" "a")
                (("C-c a" ,keymap1)
                 ("a" ,keymap1))))
    (prove:is (multiple-value-list (nkeymaps:binding-keys 'foo-b keymap1))
              `(("b")
                (("b" ,keymap1))))
    (prove:is (nkeymaps:binding-keys 'missing keymap1)
              nil)
    (nkeymaps:define-key keymap2 "a" 'foo-a)
    (nkeymaps:define-key keymap2 "c" 'foo-a)
    (prove:is (multiple-value-list (nkeymaps:binding-keys 'foo-a (list keymap1 keymap2)))
              `(("C-c a" "a" "c")
                (("C-c a" ,keymap1)
                 ("a" ,keymap1)
                 ("c" ,keymap2))))

    ;; Ordering:
    (nkeymaps:define-key keymap1 "E" 'bar-e)
    (nkeymaps:define-key keymap1 "F" 'bar-f)
    (nkeymaps:define-key keymap2 "D" 'bar-e)
    (nkeymaps:define-key keymap2 "G" 'bar-f)
    (prove:is (multiple-value-list (nkeymaps:binding-keys 'bar-e (list keymap1 keymap2)))
              `(("E" "D")
                (("E" ,keymap1)
                 ("D" ,keymap2))))
    (prove:is (multiple-value-list (nkeymaps:binding-keys 'bar-e (list keymap2 keymap1)))
              `(("D" "E")
                (("D" ,keymap2)
                 ("E" ,keymap1))))
    (prove:is (multiple-value-list (nkeymaps:binding-keys 'bar-f (list keymap1 keymap2)))
              `(("F" "G")
                (("F" ,keymap1)
                 ("G" ,keymap2))))
    (prove:is (multiple-value-list (nkeymaps:binding-keys 'bar-f (list keymap2 keymap1)))
              `(("G" "F")
                (("G" ,keymap2)
                 ("F" ,keymap1))))

    ;; Inheritance:
    (prove:is (multiple-value-list (nkeymaps:binding-keys 'foo-a keymap3))
              `(("C-c a" "a")
                (("C-c a" ,keymap1)
                 ("a" ,keymap1))))

    ;; Shadowing:
    (nkeymaps:define-key keymap3 "a" 'shadowed-a)
    (prove:is (multiple-value-list (nkeymaps:binding-keys 'foo-a keymap3))
              `(("C-c a")
                (("C-c a" ,keymap1))))))

(prove:subtest "undefine"
  (let* ((keymap (empty-keymap)))
    (nkeymaps:define-key keymap "a" 'foo-a)
    (nkeymaps:define-key keymap "a" nil)
    (prove:is (nkeymaps::entries keymap)
              (fset:empty-map)
              :test 'fset:equal?)
    (nkeymaps:define-key keymap "C-c b" 'foo-b)
    (nkeymaps:define-key keymap "C-c b" nil)
    (prove:is (nkeymaps::entries keymap)
              (fset:empty-map)
              :test 'fset:equal?)))

(prove:subtest "remap"
  (let* ((keymap (empty-keymap))
         (keymap2 (empty-keymap)))
    (nkeymaps:define-key keymap "a" 'foo-a)
    (nkeymaps:define-key keymap '(:remap foo-a) 'foo-b)
    (prove:is (nkeymaps:lookup-key "a" keymap)
              'foo-b)
    (nkeymaps:define-key keymap2 "b" 'bar-1)
    (nkeymaps:define-key keymap `(:remap bar-1 ,keymap2) 'bar-2)
    (prove:is (nkeymaps:lookup-key "b" keymap)
              'bar-2)))

(prove:subtest "retrieve translated key"
  (let* ((keymap (empty-keymap)))
    (nkeymaps:define-key keymap "a" 'foo-a)
    (multiple-value-bind (hit km key)
        (nkeymaps:lookup-key "s-A" keymap)
      (prove:is hit 'foo-a)
      (prove:is km keymap)
      (prove:is (nkeymaps:keys->keyspecs key) "a"))))

(prove:subtest "Don't shadow a prefix keymap"
  (let* ((parent (empty-keymap))
         (keymap (empty-keymap parent)))
    (nkeymaps:define-key parent "C-x" 'parent-x)
    (nkeymaps:define-key keymap "C-x C-f" 'keymap-x)
    (prove:is (nkeymaps:lookup-key "C-x C-f" keymap)
              'keymap-x)
    (prove:is (nkeymaps:lookup-key "C-x C-f" parent)
              nil)
    (prove:is (nkeymaps:lookup-key "C-x" parent)
              'parent-x)))

(prove:finalize)
